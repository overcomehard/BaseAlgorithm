# 复杂度计算

## 何为复杂度?

- 复杂度: 用于衡量算法性能的一种评价指标
- 算法性能通常可以从两个方面进行描述: 时间消耗, 内存空间占用
- 空间复杂度容易理解, 也就是程序中各变量的内存占用
    - 例如, 一段程序中申请了2个循环变量, 一个大小为N的数组
    - 为了简化计算, 暂不考虑不同数据类型所占用的内存大小, 单位均为1
    - 那么例子中占用内存空间为: N+2
    - 显然, 当N越大时, 内存占用将会越多.
    - 现, 假设有2段程序, 实现相同的功能, 其空间占用情况经过统计, 分别为: $N^2 + N + 10$, $N \log N + 10N +100$
    - 请问谁更好呢?
    - 如果要严格的按照数学方式进行比较: 大概会得出一个N的临界值, 当大于临界值时后者算法更好, 当小于临界值时前者更好
    - 但需明白, 当N比较小时, 用各种算法并没有太大的差别, 因为计算机计算都是一瞬间的事情
    - 我们更希望看到当$N \rightarrow \infty $时, 谁更好
    - 另外, 当$N \rightarrow \infty $时, 对整个空间占用式子起关键作用的是"最高幂项", 那么两段算法的空间占用情况可改写为: $O(N^2)$, $O(N \log N)$, 这也就是两段程序的空间复杂度
    - 不难看出, 后者的算法性能更好
- 有了前面对空间复杂度的介绍, 时间复杂度也就容易了
    - 一段程序的时间消耗可以归纳为: 基本执行单元执行的次数总和. 其中的执行单元可以为: 赋值运算, 比较运算, 四则运算等等
        - 同样也是为了简化计算, 才将各种基本运算都看成相同时间消耗, 均为1
        - 在遇到实际的问题时, 可以再更深入的研究(有时可能会将空间开销减半, 时间消耗减半等功效)
    - 同样, 时间复杂度只关心"最高幂"即可

## 案例分析

- 遍历一维数组A的复杂度分析

    ```C
    #include <iostream>
    
    void print_array(int *arr, int n)
    {
        for(int i=0; i<n; i++)            // 时间占用: 2*n+2,  空间占用: 1
            std::cout << arr[0] << ",";   // 时间占用: n,      空间占用: 0
        std::cout << std::endl;           // 时间占用: 1,      空间占用: 0
    }
    ```
    
    - 时间占用为: $2n + 2 + n + 1 = 3n + 3$, 时间复杂度为: $O(n)$
    - 空间占用为: $1+0+0 = 1$, 空间复杂度为: $O(1)$
    - 常数复杂度均可写为: $O(1)$, 不会随着问题规模变大而改变
    - for的那行时间占用为什么是$2n+2$?

- 冒泡排序的复杂度分析

    ```C
    void bubble_sort (int *arr, int n) {
        int temp, i, j;                     // 时间占用: 3,           空间占用: 3
        for (i=0; i<n-1; i++)               // 时间占用: 2*(n-1)+2,   空间占用: 0
            for (j=0; j<n-1-i; j++)         //   时间占用: 2*(n-1-i)+2, 空间占用: 0
            {
                if (arr[j] > arr[j+1])      //   时间占用: n-1-i,       空间占用: 0
                {
                    temp = arr[j];          //   时间占用: n-1-i,       空间占用: 0
                    arr[j] = arr[j+1];      //   时间占用: n-1-i,       空间占用: 0
                    arr[j+1] = temp;        //   时间占用: n-1-i,       空间占用: 0
                }
            }
    }
    ```
    
    - 例子中书写方式带有缩进, 只是为了便于理解内存循环与外层循环的关系
    - 内存循环的实际执行次数和为: $\sum_{i=0}^{n-2}(2(n-1-i)+2 + 4(n-1-i)) = \sum_{i=0}^{n-2}(6(n-1-i) + 2) = \frac{(n-1)(6n+4)}{2}$
    - 时间占用为: $3 + 2(n-1)+2 + \frac{(n-1)(6n+4)}{2} = \frac{(n-1)(6n+4)}{2} + 2n + 3$, 时间复杂度为: $O(n^2)$
    - 空间占用为: $3$, 空间复杂度为: $O(1)$

- 计算阶乘(递归方式)的时间复杂度分析

    ```C
    long computer_factorial(int n)            // 函数调用次数: n
    {
        if (n <= 0)                           // 时间占用: 1,  空间占用: 0
            return 0;                         // 时间占用: 1,  空间占用: 0
        if (n == 1)                           // 时间占用: 1,  空间占用: 0
            return 1;                         // 时间占用: 1,  空间占用: 0
        return n*computer_factorial(n-1);     // 时间占用: 2,  空间占用: 0
    }
    ```

    - 时间占用为: $n (1+1+1+1+2) = 6n$, 时间复杂度为: $O(n)$
    - 空间占用为: $n (0+0+0+0+0) = 0$, 空间复杂度为: $O(1)$
    - 函数调用次数乘以函数内部的执行情况
    - 最后一行的时间占用为2, 是因为一次乘法运算和一次减法运算
