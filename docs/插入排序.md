# 插入排序

## 思想

- 把n个元素的数列分成有序(前)和无序(后)的两部分
- 每次处理就是将无序的数列中第一个元素与有序数列的元素从后到前比较, 找到插入位置, 将该元素插入到有序数列的适当的最终的位置上
- 复杂度分析
    - 空间复杂度: 只需要一个临时变量, 所以复杂度为: $O(1)$
    - 时间复杂度
        - 最好的情况: 假设输入数组正好是排序好的, 那么此时不需要做任何移动操作, 复杂度为: $O(n)$
        - 最坏的情况: 假设输入数组正好是逆序的, 复杂度为: $O(n^2)$
- 这里涉及到一个概念: 稳定排序, 如果待排序的数组中包含多个相同的数值, 那么排序后, 其顺序与原来是一致的. 插入排序属于稳定排序.

## 代码

```C
// 顺序表方式实现
void insert_sort(int *array, int n)
{
    // 为什么从1开始呢?
    for(int i = 1; i < n; ++i)
    {
        // 注意这里的实现, 不是每次都交换两数, 一个小技巧
        // 为了便于理解, 不妨对比一下每次都交换两数的代码, 比较一下计算量, 看看每次都交换时其中的规律
        /*
        for(int j = i; j > 0 && array[j-1] > array[j]; --j)
        {
            int tmp = array[j];
            array[j] = array[j-1];
            array[j-1] = tmp;
        }
        */
        // 内存循环是倒序的, 可否使用顺序呢?
        // 不可以, 因为这样处理后就变成冒泡排序了
        int tmp = array[i];
        for(int j = i; j > 0 && array[j-1] > array[j]; --j)
            array[j] = array[j-1];
        array[j] = tmp;
    }
}

// 链表(单链表)实现方式

typedef struct node
{
    float value;
    typedef struct node *next;
};

void insert_sort(typedef struct node *array, int n)
{
}
```
