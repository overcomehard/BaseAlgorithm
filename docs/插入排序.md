# 插入排序

## 思想

- 把n个元素的数列分成有序(前)和无序(后)的两部分
- 每次将无序的数列中第一个元素与有序数列的元素从后到前比较, 找到插入位置, 将该元素插入到有序数列的适当的最终的位置上
- 如何找到这个合适的位置比较有讲究
    - 如果正序找到该位置, 则需要将有序部分该位置后的元素全部后移一个位置, 再将待插入元素插入该位置. 这样操作, 相当于遍历了整个有序部分的元素, 没有将有序的能力体现出来
    - 如果倒序找到该位置, 当然同样需要将元素后移一个位置, 但此时并不需要遍历有序部分的前面元素
    - 那么可否进行二分查找到该位置呢? 对于双向链表的情况是完全可以的. 但对于顺序表, 由于需要移动元素位置, 不能起到作用, 而且还增加了计算量
- 复杂度分析
    - 空间复杂度: 只需要一个临时变量, 所以复杂度为: $O(1)$
    - 时间复杂度
        - 最好的情况: 假设输入数组正好是排序好的, 那么此时不需要做任何移动操作, 复杂度为: $O(n)$
            - 因为每轮的待插入元素都只需要跟前一个元素比较一次
            - 所以相当于只有最外层的大循环N次, 因此时间复杂度为$O(n)$
        - 最坏的情况: 假设输入数组正好是逆序的, 复杂度为: $O(n^2)$
            - 因为每轮的带插入元素需要跟有序部分的全部进行比较, 直到比较到第一个元素才停止
            - 因此, 时间复杂度相当于是$O(1+2+...+(n-1)) = O(\frac{(n-1)n}{2}) = O(n^2)$
        - 平均情况: 留做思考?
- 这里涉及到一个概念: 稳定排序, 如果待排序的数组中包含多个相同的数值, 那么排序后, 其顺序与原来是一致的. 插入排序属于稳定排序.

## 代码

```C
// 顺序表方式实现
void insert_sort(int *array, int n)
{
    if (n <= 1)
        return;
    // 为什么从1开始呢?
    for(int i = 1; i < n; ++i)
    {
        // 注意这里的实现, 不是每次都交换两数, 一个小技巧
        // 为了便于理解, 不妨对比一下每次都交换两数的代码, 比较一下计算量, 看看每次都交换时其中的规律
        /*
        for(int j = i; j > 0 && array[j-1] > array[j]; --j)
        {
            int tmp = array[j];
            array[j] = array[j-1];
            array[j-1] = tmp;
        }
        */
        // 内存循环是倒序的, 可否使用顺序呢?
        // 不可以, 因为这样处理后就变成冒泡排序了
        int tmp = array[i];
        for(int j = i; j > 0 && array[j-1] > array[j]; --j)
            array[j] = array[j-1];
        array[j] = tmp;
    }
}

// 链表(单链表)实现方式
// 该实现中注意要保证原有顺序的稳定性

typedef struct node
{
    float value;
    typedef struct node *next;
};

void insert_sort(typedef struct node *array, int n)
{
}
```
